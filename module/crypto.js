const { rejects } = require('assert');
const crypto = require('crypto');
const data = 'pw1234'; //얘가 하나의 비밀번호로 사용됨 

let encData  = crypto.createHash('sha512').update(data).digest('base64'); //Hash 가장 대중적으로 쓰는 알고리즘 hash (sha-512). 결과를 몇자리로 처리할 건지 원본을 알아보기 어렵도록 길게 늘리는것 
//9iSeOd1vv2qinR2UM5Aog5LmqBncF/oFeTTsPUjqwGoG3lG232280LqAScE7FR7HHe4K0gyedCN7iZDZl+NZaA== 저장할 때는 이 형태로 저장됨
console.log(data,encData);

encData  = crypto.createHash('sha512').update(data).digest('hex'); //hex는 좀 더 길게 표시가 됨. 
console.log(data,encData);

//salting 암호화 
const createSalt = ()=>{
    return new Promise((resolve,reject)=>{
        crypto.randomBytes(64,(err,buf)=>{ //buf argument is a Buffer containing the generated bytes.
            if(err) reject(err);
            resolve(buf.toString('base64'));
        })
    })
}

const createCryptoPassword = async(plainPassword)=>{
    const salt = await createSalt();

    return new Promise((resolve,reject)=>{
        crypto.pbkdf2(plainPassword,
                                salt,
                                9999,
                                64,
                                'sha512',
                                (err,key)=>{
                        if(err) reject(err);
                        resolve({password: key.toString('base64'),salt}); //객체 타입으로 생성해서 넘기기
        })
    })
};
const cryptoPassword = async()=>{
    encData = await createCryptoPassword(data); //이 방식 or 아래 있는 방식 쓰든 상관 없음
    console.log(encData);
}
cryptoPassword();

createCryptoPassword(data)
.then(result=> console.log(result))
.catch(err=>console.log(err));